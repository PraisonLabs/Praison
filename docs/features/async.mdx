---
title: "Async AI Agents"
description: "Async AI Agents allow you to run AI tasks asynchronously, improving performance and efficiency in your applications."
icon: "clock"
---

<Note>
  **Requirements**
  
  - Python 3.10 or higher
  - Basic understanding of async/await in Python
</Note>

## Quick Start

<Steps>
  <Step title="Install Package">
    First, install the PraisonAI Agents package:
    ```bash
    pip install praisonaiagents
    ```
  </Step>

  <Step title="Set API Key">
    Set your OpenAI API key as an environment variable:
    ```bash
    export OPENAI_API_KEY=your_api_key_here
    ```
  </Step>

  <Step title="Create Project">
    Create a new file `app.py` with the basic setup:
    ```python
    import asyncio
    from praisonaiagents import Agent, Task, PraisonAIAgents

    # Create an agent
    agent = Agent(
        name="AsyncAgent",
        role="Assistant",
        goal="Help with tasks",
        backstory="Expert in async operations"
    )

    # Create a task
    task = Task(
        name="hello_task",
        description="Say hello and introduce yourself",
        agent=agent,
        async_execution=True
    )

    # Create agents manager
    agents = PraisonAIAgents(
        agents=[agent],
        tasks=[task],
        process="sequential"
    )

    # Main async function
    async def main():
        result = await agents.astart()
        print(result)

    # Run the program
    if __name__ == "__main__":
        asyncio.run(main())
    ```
  </Step>

  <Step title="Run the Program">
    Run your async AI agent:
    ```bash
    python app.py
    ```
  </Step>
</Steps>

## Understanding Async Execution

<Card title="What is Asynchronous Execution?" icon="question">
  Async execution lets your program continue running while waiting for operations to complete. This is ideal for:
  - Making multiple AI API calls
  - Processing large datasets
  - Handling multiple tasks simultaneously
  - Maintaining responsive applications
</Card>

<CodeGroup>
  ```python Sync
  # Synchronous execution (blocks until complete)
  result = agent.chat("Hello")
  ```

  ```python Async
  # Asynchronous execution (non-blocking)
  result = await agent.achat("Hello")
  ```
</CodeGroup>

## Features

<CardGroup cols={2}>
  <Card title="Async Tasks" icon="tasks">
    Create tasks that run asynchronously with built-in error handling and retries.
  </Card>
  <Card title="Parallel Processing" icon="arrows-split-up-and-left">
    Run multiple tasks in parallel using asyncio.gather().
  </Card>
  <Card title="Mixed Mode" icon="shuffle">
    Mix sync and async tasks in the same workflow seamlessly.
  </Card>
  <Card title="Resource Management" icon="gear">
    Built-in resource management and performance optimization.
  </Card>
</CardGroup>

## Advanced Usage

### 1. Async Tasks with Callbacks

<CodeGroup>
  ```python Task
  # Create an async task with callback
  async_task = Task(
      name="weather_task",
      description="Check weather conditions",
      agent=agent,
      async_execution=True,
      callback=async_callback
  )
  ```

  ```python Callback
  async def async_callback(output):
      await process_result(output)
      await save_to_database(output)
  ```
</CodeGroup>

### 2. Parallel Task Processing

<Warning>
  Be mindful of rate limits and resource usage when processing tasks in parallel.
</Warning>

```python
async def process_multiple_tasks():
    tasks = [
        Task(
            name=f"task_{i}",
            description=f"Process item {i}",
            async_execution=True
        ) for i in range(5)
    ]
    
    results = await asyncio.gather(
        *[agent.achat(task.description) for task in tasks]
    )
    return results
```

## Best Practices

<AccordionGroup>
  <Accordion title="Error Handling">
    ```python
    async def safe_async_operation():
        try:
            result = await agent.achat("Process this")
            return result
        except Exception as e:
            logging.error(f"Error: {e}")
            return None
    ```
  </Accordion>

  <Accordion title="Resource Management">
    ```python
    async def efficient_processing():
        semaphore = asyncio.Semaphore(5)
        async with semaphore:
            result = await agent.achat("Process within limits")
        return result
    ```
  </Accordion>

  <Accordion title="Performance Tips">
    - Use `asyncio.gather()` for parallel operations
    - Implement proper error handling
    - Monitor memory usage
    - Use timeouts for long-running operations
  </Accordion>
</AccordionGroup>

## Troubleshooting

<CardGroup cols={2}>
  <Card title="ChatCompletion Error" icon="triangle-exclamation">
    If you see "ChatCompletion can't be used in await expression":
    - Use AsyncOpenAI() client
    - Ensure proper async context
  </Card>

  <Card title="Event Loop Error" icon="circle-exclamation">
    If you get "Event loop is closed":
    - Use asyncio.run() for main entry
    - Check async context
  </Card>
</CardGroup>

## API Reference

### Async Methods

<ResponseField name="achat()" type="async">
  Async version of chat method
</ResponseField>

<ResponseField name="aexecute_tool()" type="async">
  Async tool execution method
</ResponseField>

<ResponseField name="astart()" type="async">
  Async task execution starter
</ResponseField>

### Task Properties

<ResponseField name="async_execution" type="boolean">
  Enable/disable async mode for tasks
</ResponseField>

<ResponseField name="callback" type="function">
  Set sync or async callback function
</ResponseField>

## Next Steps

<CardGroup cols={2}>
  <Card title="Examples" icon="code" href="./examples">
    Check out more examples in our examples directory
  </Card>
  <Card title="Advanced Topics" icon="book" href="./advanced">
    Learn about advanced async patterns and optimizations
  </Card>
</CardGroup>

<Note>
  Remember to handle errors properly, manage resources efficiently, and test thoroughly in async contexts.
</Note>
