{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Praison AI","text":"<p>Praison AI, leveraging both AutoGen and CrewAI or any other agent framework, represents a low-code, centralised framework designed to simplify the creation and orchestration of multi-agent systems for various LLM applications, emphasizing ease of use, customization, and human-agent interaction.</p>"},{"location":"#prerequisite","title":"Prerequisite:","text":""},{"location":"#export-api-key","title":"Export API KEY","text":"<pre><code>export OPENAI_API_KEY=\"Enter your API key\"\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install praisonai\n</code></pre>"},{"location":"#automatically-create-agents-to-perform-a-task","title":"Automatically Create Agents to Perform a Task","text":"<pre><code>praisonai --init create a movie script about dog in moon\n</code></pre>"},{"location":"#run","title":"Run","text":"<pre><code>praisonai\n</code></pre>"},{"location":"agents_playbook/","title":"Agents Playbook","text":""},{"location":"agents_playbook/#simple-playbook-example","title":"Simple Playbook Example","text":"<pre><code>framework: crewai\ntopic: Artificial Intelligence\nroles:\n  screenwriter:\n    backstory: 'Skilled in crafting scripts with engaging dialogue about {topic}.'\n    goal: Create scripts from concepts.\n    role: Screenwriter\n    tasks:\n      scriptwriting_task:\n        description: 'Develop scripts with compelling characters and dialogue about {topic}.'\n        expected_output: 'Complete script ready for production.'\n</code></pre>"},{"location":"agents_playbook/#detailed-playbook-example","title":"Detailed Playbook Example","text":"<pre><code>framework: crewai\ntopic: Artificial Intelligence\nroles:\n  movie_concept_creator:\n    backstory: 'Creative thinker with a deep understanding of cinematic storytelling,\n      capable of using AI-generated storylines to create unique and compelling movie\n      ideas.'\n    goal: Generate engaging movie concepts using AI storylines\n    role: Movie Concept Creator\n    tasks:\n      movie_concept_development:\n        description: 'Develop movie concepts from AI-generated storylines, ensuring\n          they are engaging and have strong narrative arcs.'\n        expected_output: 'Well-structured movie concept document with character\n          bios, settings, and plot outlines.'\n  screenwriter:\n    backstory: 'Expert in writing engaging dialogue and script structure, able to\n      turn movie concepts into production-ready scripts.'\n    goal: Write compelling scripts based on movie concepts\n    role: Screenwriter\n    tasks:\n      scriptwriting_task:\n        description: 'Turn movie concepts into polished scripts with well-developed\n          characters, strong dialogue, and effective scene transitions.'\n        expected_output: 'Production-ready script with a beginning, middle, and\n          end, along with character development and engaging dialogues.'\n  editor:\n    backstory: 'Adept at identifying inconsistencies, improving language usage,\n      and maintaining the overall flow of the script.'\n    goal: Refine the scripts and ensure continuity of the movie storyline\n    role: Editor\n    tasks:\n      editing_task:\n        description: 'Review, edit, and refine the scripts to ensure they are cohesive\n          and follow a well-structured narrative.'\n        expected_output: 'A polished final draft of the script with no inconsistencies,\n          strong character development, and effective dialogue.'\ndependencies: []\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#praisonai.auto.AutoGenerator","title":"<code>AutoGenerator</code>","text":"Source code in <code>praisonai/auto.py</code> <pre><code>class AutoGenerator:\n    def __init__(self, topic=\"Movie Story writing about AI\", agent_file=\"test.yaml\", framework=\"crewai\"):\n        \"\"\"\n        Initialize the AutoGenerator class with the specified topic, agent file, and framework.\n        note: autogen framework is different from this AutoGenerator class.\n\n        Args:\n            topic (str, optional): The topic for the generated team structure. Defaults to \"Movie Story writing about AI\".\n            agent_file (str, optional): The name of the YAML file to save the generated team structure. Defaults to \"test.yaml\".\n            framework (str, optional): The framework for the generated team structure. Defaults to \"crewai\".\n\n        Attributes:\n            config_list (list): A list containing the configuration details for the OpenAI API.\n            topic (str): The specified topic for the generated team structure.\n            agent_file (str): The specified name of the YAML file to save the generated team structure.\n            framework (str): The specified framework for the generated team structure.\n            client (instructor.Client): An instance of the instructor.Client class initialized with the specified OpenAI API configuration.\n        \"\"\"\n        self.config_list = [\n            {\n                'model': os.environ.get(\"OPENAI_MODEL_NAME\", \"gpt-4o\"),\n                'base_url': os.environ.get(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\"),\n            }\n        ]\n        self.topic = topic\n        self.agent_file = agent_file\n        self.framework = framework or \"crewai\"\n        self.client = instructor.patch(\n            OpenAI(\n                base_url=self.config_list[0]['base_url'],\n                api_key=os.getenv(\"OPENAI_API_KEY\"),\n            ),\n            mode=instructor.Mode.JSON,\n        )\n\n    def generate(self):\n        \"\"\"\n        Generates a team structure for the specified topic.\n\n        Args:\n            None\n\n        Returns:\n            str: The full path of the YAML file containing the generated team structure.\n\n        Raises:\n            Exception: If the generation process fails.\n\n        Usage:\n            generator = AutoGenerator(framework=\"crewai\", topic=\"Create a movie script about Cat in Mars\")\n            path = generator.generate()\n            print(path)\n        \"\"\"\n        response = self.client.chat.completions.create(\n            model=self.config_list[0]['model'],\n            response_model=TeamStructure,\n            max_retries=10,\n            messages=[\n                {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output complex team structures.\"},\n                {\"role\": \"user\", \"content\": self.get_user_content()}\n            ]\n        )\n        json_data = json.loads(response.model_dump_json())\n        self.convert_and_save(json_data)\n        full_path = os.path.abspath(self.agent_file)\n        return full_path\n\n    def convert_and_save(self, json_data):\n        \"\"\"Converts the provided JSON data into the desired YAML format and saves it to a file.\n\n        Args:\n            json_data (dict): The JSON data representing the team structure.\n            topic (str, optional): The topic to be inserted into the YAML. Defaults to \"Artificial Intelligence\".\n            agent_file (str, optional): The name of the YAML file to save. Defaults to \"test.yaml\".\n        \"\"\"\n\n        yaml_data = {\n            \"framework\": self.framework,\n            \"topic\": self.topic,\n            \"roles\": {},\n            \"dependencies\": []\n        }\n\n        for role_id, role_details in json_data['roles'].items():\n            yaml_data['roles'][role_id] = {\n                \"backstory\": \"\" + role_details['backstory'],\n                \"goal\": role_details['goal'],\n                \"role\": role_details['role'],\n                \"tasks\": {},\n                # \"tools\": role_details.get('tools', []),\n                \"tools\": ['']\n            }\n\n            for task_id, task_details in role_details['tasks'].items():\n                yaml_data['roles'][role_id]['tasks'][task_id] = {\n                    \"description\": \"\" + task_details['description'],\n                    \"expected_output\": \"\" + task_details['expected_output']\n                }\n\n        # Save to YAML file, maintaining the order\n        with open(self.agent_file, 'w') as f:\n            yaml.dump(yaml_data, f, allow_unicode=True, sort_keys=False)\n\n    def get_user_content(self):\n        \"\"\"\n        Generates a prompt for the OpenAI API to generate a team structure.\n\n        Args:\n            None\n\n        Returns:\n            str: The prompt for the OpenAI API.\n\n        Usage:\n            generator = AutoGenerator(framework=\"crewai\", topic=\"Create a movie script about Cat in Mars\")\n            prompt = generator.get_user_content()\n            print(prompt)\n        \"\"\"\n        user_content = \"\"\"Generate a team structure for  \\\"\"\"\" + self.topic + \"\"\"\\\" task. \nNo Input data will be provided to the team.\nThe team will work in sequence. First role will pass the output to the next role, and so on.\nThe last role will generate the final output.\nThink step by step.\nWith maximum 3 roles, each with 1 task. Include role goals, backstories, task descriptions, and expected outputs.\nList of Available Tools: CodeDocsSearchTool, CSVSearchTool, DirectorySearchTool, DOCXSearchTool, DirectoryReadTool, FileReadTool, TXTSearchTool, JSONSearchTool, MDXSearchTool, PDFSearchTool, RagTool, ScrapeElementFromWebsiteTool, ScrapeWebsiteTool, WebsiteSearchTool, XMLSearchTool, YoutubeChannelSearchTool, YoutubeVideoSearchTool.\nOnly use Available Tools. Do Not use any other tools. \nExample Below: \nUse below example to understand the structure of the output. \nThe final role you create should satisfy the provided task: \"\"\" + self.topic + \"\"\".\n{\n\"roles\": {\n\"narrative_designer\": {\n\"role\": \"Narrative Designer\",\n\"goal\": \"Create AI storylines\",\n\"backstory\": \"Skilled in narrative development for AI, with a focus on story resonance.\",\n\"tools\": [\"ScrapeWebsiteTool\"],\n\"tasks\": {\n\"story_concept_development\": {\n\"description\": \"Craft a unique AI story concept with depth and engagement using concept from this page the content https://www.asthebirdfliesblog.com/posts/how-to-write-book-story-development .\",\n\"expected_output\": \"Document with narrative arcs, character bios, and settings.\"\n}\n}\n},\n\"scriptwriter\": {\n\"role\": \"Scriptwriter\",\n\"goal\": \"Write scripts from AI concepts\",\n\"backstory\": \"Expert in dialogue and script structure, translating concepts into scripts.\",\n\"tasks\": {\n\"scriptwriting_task\": {\n\"description\": \"Turn narrative concepts into scripts, including dialogue and scenes.\",\n\"expected_output\": \"Production-ready script with dialogue and scene details.\"\n}\n}\n}\n}\n}\n        \"\"\"\n        return user_content\n</code></pre>"},{"location":"api/#praisonai.auto.AutoGenerator.__init__","title":"<code>__init__(topic='Movie Story writing about AI', agent_file='test.yaml', framework='crewai')</code>","text":"<p>Initialize the AutoGenerator class with the specified topic, agent file, and framework. note: autogen framework is different from this AutoGenerator class.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic for the generated team structure. Defaults to \"Movie Story writing about AI\".</p> <code>'Movie Story writing about AI'</code> <code>agent_file</code> <code>str</code> <p>The name of the YAML file to save the generated team structure. Defaults to \"test.yaml\".</p> <code>'test.yaml'</code> <code>framework</code> <code>str</code> <p>The framework for the generated team structure. Defaults to \"crewai\".</p> <code>'crewai'</code> <p>Attributes:</p> Name Type Description <code>config_list</code> <code>list</code> <p>A list containing the configuration details for the OpenAI API.</p> <code>topic</code> <code>str</code> <p>The specified topic for the generated team structure.</p> <code>agent_file</code> <code>str</code> <p>The specified name of the YAML file to save the generated team structure.</p> <code>framework</code> <code>str</code> <p>The specified framework for the generated team structure.</p> <code>client</code> <code>Client</code> <p>An instance of the instructor.Client class initialized with the specified OpenAI API configuration.</p> Source code in <code>praisonai/auto.py</code> <pre><code>def __init__(self, topic=\"Movie Story writing about AI\", agent_file=\"test.yaml\", framework=\"crewai\"):\n    \"\"\"\n    Initialize the AutoGenerator class with the specified topic, agent file, and framework.\n    note: autogen framework is different from this AutoGenerator class.\n\n    Args:\n        topic (str, optional): The topic for the generated team structure. Defaults to \"Movie Story writing about AI\".\n        agent_file (str, optional): The name of the YAML file to save the generated team structure. Defaults to \"test.yaml\".\n        framework (str, optional): The framework for the generated team structure. Defaults to \"crewai\".\n\n    Attributes:\n        config_list (list): A list containing the configuration details for the OpenAI API.\n        topic (str): The specified topic for the generated team structure.\n        agent_file (str): The specified name of the YAML file to save the generated team structure.\n        framework (str): The specified framework for the generated team structure.\n        client (instructor.Client): An instance of the instructor.Client class initialized with the specified OpenAI API configuration.\n    \"\"\"\n    self.config_list = [\n        {\n            'model': os.environ.get(\"OPENAI_MODEL_NAME\", \"gpt-4o\"),\n            'base_url': os.environ.get(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\"),\n        }\n    ]\n    self.topic = topic\n    self.agent_file = agent_file\n    self.framework = framework or \"crewai\"\n    self.client = instructor.patch(\n        OpenAI(\n            base_url=self.config_list[0]['base_url'],\n            api_key=os.getenv(\"OPENAI_API_KEY\"),\n        ),\n        mode=instructor.Mode.JSON,\n    )\n</code></pre>"},{"location":"api/#praisonai.auto.AutoGenerator.convert_and_save","title":"<code>convert_and_save(json_data)</code>","text":"<p>Converts the provided JSON data into the desired YAML format and saves it to a file.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>dict</code> <p>The JSON data representing the team structure.</p> required <code>topic</code> <code>str</code> <p>The topic to be inserted into the YAML. Defaults to \"Artificial Intelligence\".</p> required <code>agent_file</code> <code>str</code> <p>The name of the YAML file to save. Defaults to \"test.yaml\".</p> required Source code in <code>praisonai/auto.py</code> <pre><code>def convert_and_save(self, json_data):\n    \"\"\"Converts the provided JSON data into the desired YAML format and saves it to a file.\n\n    Args:\n        json_data (dict): The JSON data representing the team structure.\n        topic (str, optional): The topic to be inserted into the YAML. Defaults to \"Artificial Intelligence\".\n        agent_file (str, optional): The name of the YAML file to save. Defaults to \"test.yaml\".\n    \"\"\"\n\n    yaml_data = {\n        \"framework\": self.framework,\n        \"topic\": self.topic,\n        \"roles\": {},\n        \"dependencies\": []\n    }\n\n    for role_id, role_details in json_data['roles'].items():\n        yaml_data['roles'][role_id] = {\n            \"backstory\": \"\" + role_details['backstory'],\n            \"goal\": role_details['goal'],\n            \"role\": role_details['role'],\n            \"tasks\": {},\n            # \"tools\": role_details.get('tools', []),\n            \"tools\": ['']\n        }\n\n        for task_id, task_details in role_details['tasks'].items():\n            yaml_data['roles'][role_id]['tasks'][task_id] = {\n                \"description\": \"\" + task_details['description'],\n                \"expected_output\": \"\" + task_details['expected_output']\n            }\n\n    # Save to YAML file, maintaining the order\n    with open(self.agent_file, 'w') as f:\n        yaml.dump(yaml_data, f, allow_unicode=True, sort_keys=False)\n</code></pre>"},{"location":"api/#praisonai.auto.AutoGenerator.generate","title":"<code>generate()</code>","text":"<p>Generates a team structure for the specified topic.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The full path of the YAML file containing the generated team structure.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the generation process fails.</p> Usage <p>generator = AutoGenerator(framework=\"crewai\", topic=\"Create a movie script about Cat in Mars\") path = generator.generate() print(path)</p> Source code in <code>praisonai/auto.py</code> <pre><code>def generate(self):\n    \"\"\"\n    Generates a team structure for the specified topic.\n\n    Args:\n        None\n\n    Returns:\n        str: The full path of the YAML file containing the generated team structure.\n\n    Raises:\n        Exception: If the generation process fails.\n\n    Usage:\n        generator = AutoGenerator(framework=\"crewai\", topic=\"Create a movie script about Cat in Mars\")\n        path = generator.generate()\n        print(path)\n    \"\"\"\n    response = self.client.chat.completions.create(\n        model=self.config_list[0]['model'],\n        response_model=TeamStructure,\n        max_retries=10,\n        messages=[\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output complex team structures.\"},\n            {\"role\": \"user\", \"content\": self.get_user_content()}\n        ]\n    )\n    json_data = json.loads(response.model_dump_json())\n    self.convert_and_save(json_data)\n    full_path = os.path.abspath(self.agent_file)\n    return full_path\n</code></pre>"},{"location":"api/#praisonai.auto.AutoGenerator.get_user_content","title":"<code>get_user_content()</code>","text":"<p>Generates a prompt for the OpenAI API to generate a team structure.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The prompt for the OpenAI API.</p> Usage <p>generator = AutoGenerator(framework=\"crewai\", topic=\"Create a movie script about Cat in Mars\") prompt = generator.get_user_content() print(prompt)</p> Source code in <code>praisonai/auto.py</code> <pre><code>    def get_user_content(self):\n        \"\"\"\n        Generates a prompt for the OpenAI API to generate a team structure.\n\n        Args:\n            None\n\n        Returns:\n            str: The prompt for the OpenAI API.\n\n        Usage:\n            generator = AutoGenerator(framework=\"crewai\", topic=\"Create a movie script about Cat in Mars\")\n            prompt = generator.get_user_content()\n            print(prompt)\n        \"\"\"\n        user_content = \"\"\"Generate a team structure for  \\\"\"\"\" + self.topic + \"\"\"\\\" task. \nNo Input data will be provided to the team.\nThe team will work in sequence. First role will pass the output to the next role, and so on.\nThe last role will generate the final output.\nThink step by step.\nWith maximum 3 roles, each with 1 task. Include role goals, backstories, task descriptions, and expected outputs.\nList of Available Tools: CodeDocsSearchTool, CSVSearchTool, DirectorySearchTool, DOCXSearchTool, DirectoryReadTool, FileReadTool, TXTSearchTool, JSONSearchTool, MDXSearchTool, PDFSearchTool, RagTool, ScrapeElementFromWebsiteTool, ScrapeWebsiteTool, WebsiteSearchTool, XMLSearchTool, YoutubeChannelSearchTool, YoutubeVideoSearchTool.\nOnly use Available Tools. Do Not use any other tools. \nExample Below: \nUse below example to understand the structure of the output. \nThe final role you create should satisfy the provided task: \"\"\" + self.topic + \"\"\".\n{\n\"roles\": {\n\"narrative_designer\": {\n\"role\": \"Narrative Designer\",\n\"goal\": \"Create AI storylines\",\n\"backstory\": \"Skilled in narrative development for AI, with a focus on story resonance.\",\n\"tools\": [\"ScrapeWebsiteTool\"],\n\"tasks\": {\n\"story_concept_development\": {\n\"description\": \"Craft a unique AI story concept with depth and engagement using concept from this page the content https://www.asthebirdfliesblog.com/posts/how-to-write-book-story-development .\",\n\"expected_output\": \"Document with narrative arcs, character bios, and settings.\"\n}\n}\n},\n\"scriptwriter\": {\n\"role\": \"Scriptwriter\",\n\"goal\": \"Write scripts from AI concepts\",\n\"backstory\": \"Expert in dialogue and script structure, translating concepts into scripts.\",\n\"tasks\": {\n\"scriptwriting_task\": {\n\"description\": \"Turn narrative concepts into scripts, including dialogue and scenes.\",\n\"expected_output\": \"Production-ready script with dialogue and scene details.\"\n}\n}\n}\n}\n}\n        \"\"\"\n        return user_content\n</code></pre>"},{"location":"api/#praisonai.agents_generator.AgentsGenerator","title":"<code>AgentsGenerator</code>","text":"Source code in <code>praisonai/agents_generator.py</code> <pre><code>class AgentsGenerator:\n    def __init__(self, agent_file, framework, config_list):\n        \"\"\"\n        Initialize the AgentsGenerator object.\n\n        Parameters:\n            agent_file (str): The path to the agent file.\n            framework (str): The framework to be used for the agents.\n            config_list (list): A list of configurations for the agents.\n\n        Attributes:\n            agent_file (str): The path to the agent file.\n            framework (str): The framework to be used for the agents.\n            config_list (list): A list of configurations for the agents.\n        \"\"\"\n        self.agent_file = agent_file\n        self.framework = framework\n        self.config_list = config_list\n\n    def is_function_or_decorated(self, obj):\n        \"\"\"\n        Checks if the given object is a function or has a __call__ method.\n\n        Parameters:\n            obj (object): The object to be checked.\n\n        Returns:\n            bool: True if the object is a function or has a __call__ method, False otherwise.\n        \"\"\"\n        return inspect.isfunction(obj) or hasattr(obj, '__call__')\n\n    def load_tools_from_module(self, module_path):\n        \"\"\"\n        Loads tools from a specified module path.\n\n        Parameters:\n            module_path (str): The path to the module containing the tools.\n\n        Returns:\n            dict: A dictionary containing the names of the tools as keys and the corresponding functions or objects as values.\n\n        Raises:\n            FileNotFoundError: If the specified module path does not exist.\n        \"\"\"\n        spec = importlib.util.spec_from_file_location(\"tools_module\", module_path)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return {name: obj for name, obj in inspect.getmembers(module, self.is_function_or_decorated)}\n\n    def load_tools_from_module_class(self, module_path):\n        \"\"\"\n        Loads tools from a specified module path containing classes that inherit from BaseTool or are part of langchain_community.tools package.\n\n        Parameters:\n            module_path (str): The path to the module containing the tools.\n\n        Returns:\n            dict: A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.\n\n        Raises:\n            FileNotFoundError: If the specified module path does not exist.\n        \"\"\"\n        spec = importlib.util.spec_from_file_location(\"tools_module\", module_path)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return {name: obj() for name, obj in inspect.getmembers(module, lambda x: inspect.isclass(x) and (x.__module__.startswith('langchain_community.tools') or issubclass(x, BaseTool)) and x is not BaseTool)}\n\n    def load_tools_from_package(self, package_path):\n        \"\"\"\n        Loads tools from a specified package path containing modules with functions or classes.\n\n        Parameters:\n            package_path (str): The path to the package containing the tools.\n\n        Returns:\n            dict: A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.\n\n        Raises:\n            FileNotFoundError: If the specified package path does not exist.\n\n        This function iterates through all the .py files in the specified package path, excluding those that start with \"__\". For each file, it imports the corresponding module and checks if it contains any functions or classes that can be loaded as tools. The function then returns a dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.\n        \"\"\"\n        tools_dict = {}\n        for module_file in os.listdir(package_path):\n            if module_file.endswith('.py') and not module_file.startswith('__'):\n                module_name = f\"{package_path.name}.{module_file[:-3]}\"  # Remove .py for import\n                module = importlib.import_module(module_name)\n                for name, obj in inspect.getmembers(module, self.is_function_or_decorated):\n                    tools_dict[name] = obj\n        return tools_dict\n\n    def generate_crew_and_kickoff(self):\n        \"\"\"\n        Generates a crew of agents and initiates tasks based on the provided configuration.\n\n        Parameters:\n            agent_file (str): The path to the agent file.\n            framework (str): The framework to be used for the agents.\n            config_list (list): A list of configurations for the agents.\n\n        Returns:\n            str: The output of the tasks performed by the crew of agents.\n\n        Raises:\n            FileNotFoundError: If the specified agent file does not exist.\n\n        This function first loads the agent configuration from the specified file. It then initializes the tools required for the agents based on the specified framework. If the specified framework is \"autogen\", it loads the LLM configuration dynamically and creates an AssistantAgent for each role in the configuration. It then adds tools to the agents if specified in the configuration. Finally, it prepares tasks for the agents based on the configuration and initiates the tasks using the crew of agents. If the specified framework is not \"autogen\", it creates a crew of agents and initiates tasks based on the configuration.\n        \"\"\"\n        if self.agent_file == '/app/api:app' or self.agent_file == 'api:app':\n            self.agent_file = 'agents.yaml'\n        try:\n            with open(self.agent_file, 'r') as f:\n                config = yaml.safe_load(f)\n        except FileNotFoundError:\n            print(f\"File not found: {self.agent_file}\")\n            return\n\n        topic = config['topic']\n        tools_dict = {\n            'CodeDocsSearchTool': CodeDocsSearchTool(),\n            'CSVSearchTool': CSVSearchTool(),\n            'DirectorySearchTool': DirectorySearchTool(),\n            'DOCXSearchTool': DOCXSearchTool(),\n            'DirectoryReadTool': DirectoryReadTool(),\n            'FileReadTool': FileReadTool(),\n            # 'GithubSearchTool': GithubSearchTool(),\n            # 'SeperDevTool': SeperDevTool(),\n            'TXTSearchTool': TXTSearchTool(),\n            'JSONSearchTool': JSONSearchTool(),\n            'MDXSearchTool': MDXSearchTool(),\n            'PDFSearchTool': PDFSearchTool(),\n            # 'PGSearchTool': PGSearchTool(),\n            'RagTool': RagTool(),\n            'ScrapeElementFromWebsiteTool': ScrapeElementFromWebsiteTool(),\n            'ScrapeWebsiteTool': ScrapeWebsiteTool(),\n            'WebsiteSearchTool': WebsiteSearchTool(),\n            'XMLSearchTool': XMLSearchTool(),\n            'YoutubeChannelSearchTool': YoutubeChannelSearchTool(),\n            'YoutubeVideoSearchTool': YoutubeVideoSearchTool(),\n        }\n        root_directory = os.getcwd()\n        tools_py_path = os.path.join(root_directory, 'tools.py')\n        tools_dir_path = Path(root_directory) / 'tools'\n\n        if os.path.isfile(tools_py_path):\n            tools_dict.update(self.load_tools_from_module_class(tools_py_path))\n            # print(\"tools.py exists in the root directory. Loading tools.py and skipping tools folder.\")\n        elif tools_dir_path.is_dir():\n            tools_dict.update(self.load_tools_from_module_class(tools_dir_path))\n            # print(\"tools folder exists in the root directory\")\n\n        framework = self.framework or config.get('framework')\n\n        agents = {}\n        tasks = []\n        if framework == \"autogen\":\n            # Load the LLM configuration dynamically\n            # print(self.config_list)\n            llm_config = {\"config_list\": self.config_list}\n\n            # Assuming the user proxy agent is set up as per your requirements\n            user_proxy = autogen.UserProxyAgent(\n                name=\"User\",\n                human_input_mode=\"NEVER\",\n                is_termination_msg=lambda x: (x.get(\"content\") or \"\").rstrip().rstrip(\".\").lower().endswith(\"terminate\") or \"TERMINATE\" in (x.get(\"content\") or \"\"),\n                code_execution_config={\n                    \"work_dir\": \"coding\",\n                    \"use_docker\": False,\n                },\n                # additional setup for the user proxy agent\n            )\n\n            for role, details in config['roles'].items():\n                agent_name = details['role'].format(topic=topic).replace(\"{topic}\", topic)\n                agent_goal = details['goal'].format(topic=topic)\n                # Creating an AssistantAgent for each role dynamically\n                agents[role] = autogen.AssistantAgent(\n                    name=agent_name,\n                    llm_config=llm_config,\n                    system_message=details['backstory'].format(topic=topic)+\". Must Reply \\\"TERMINATE\\\" in the end when everything is done.\",\n                )\n                for tool in details.get('tools', []):\n                    if tool in tools_dict:\n                        try:\n                            tool_class = globals()[f'autogen_{type(tools_dict[tool]).__name__}']\n                            print(f\"Found {tool_class.__name__} for {tool}\")\n                        except KeyError:\n                            print(f\"Warning: autogen_{type(tools_dict[tool]).__name__} function not found. Skipping this tool.\")\n                            continue\n                        tool_class(agents[role], user_proxy)\n\n                # Preparing tasks for initiate_chats\n                for task_name, task_details in details.get('tasks', {}).items():\n                    description_filled = task_details['description'].format(topic=topic)\n                    expected_output_filled = task_details['expected_output'].format(topic=topic)\n\n                    chat_task = {\n                        \"recipient\": agents[role],\n                        \"message\": description_filled,\n                        \"summary_method\": \"last_msg\", \n                        # Additional fields like carryover can be added based on dependencies\n                    }\n                    tasks.append(chat_task)\n\n            response = user_proxy.initiate_chats(tasks)\n            result = \"### Output ###\\n\"+response[-1].summary if hasattr(response[-1], 'summary') else \"\"\n        else:\n            for role, details in config['roles'].items():\n                role_filled = details['role'].format(topic=topic)\n                goal_filled = details['goal'].format(topic=topic)\n                backstory_filled = details['backstory'].format(topic=topic)\n\n                # Adding tools to the agent if exists\n                agent_tools = [tools_dict[tool] for tool in details.get('tools', []) if tool in tools_dict]\n                agent = Agent(role=role_filled, goal=goal_filled, backstory=backstory_filled, tools=agent_tools, allow_delegation=False)\n                agents[role] = agent\n\n                for task_name, task_details in details.get('tasks', {}).items():\n                    description_filled = task_details['description'].format(topic=topic)\n                    expected_output_filled = task_details['expected_output'].format(topic=topic)\n\n                    task = Task(description=description_filled, expected_output=expected_output_filled, agent=agent)\n                    tasks.append(task)\n            crew = Crew(\n                agents=list(agents.values()),\n                tasks=tasks,\n                verbose=2\n            )\n\n            response = crew.kickoff()\n            result = f\"### Task Output ###\\n{response}\"\n        return result\n</code></pre>"},{"location":"api/#praisonai.agents_generator.AgentsGenerator.__init__","title":"<code>__init__(agent_file, framework, config_list)</code>","text":"<p>Initialize the AgentsGenerator object.</p> <p>Parameters:</p> Name Type Description Default <code>agent_file</code> <code>str</code> <p>The path to the agent file.</p> required <code>framework</code> <code>str</code> <p>The framework to be used for the agents.</p> required <code>config_list</code> <code>list</code> <p>A list of configurations for the agents.</p> required <p>Attributes:</p> Name Type Description <code>agent_file</code> <code>str</code> <p>The path to the agent file.</p> <code>framework</code> <code>str</code> <p>The framework to be used for the agents.</p> <code>config_list</code> <code>list</code> <p>A list of configurations for the agents.</p> Source code in <code>praisonai/agents_generator.py</code> <pre><code>def __init__(self, agent_file, framework, config_list):\n    \"\"\"\n    Initialize the AgentsGenerator object.\n\n    Parameters:\n        agent_file (str): The path to the agent file.\n        framework (str): The framework to be used for the agents.\n        config_list (list): A list of configurations for the agents.\n\n    Attributes:\n        agent_file (str): The path to the agent file.\n        framework (str): The framework to be used for the agents.\n        config_list (list): A list of configurations for the agents.\n    \"\"\"\n    self.agent_file = agent_file\n    self.framework = framework\n    self.config_list = config_list\n</code></pre>"},{"location":"api/#praisonai.agents_generator.AgentsGenerator.generate_crew_and_kickoff","title":"<code>generate_crew_and_kickoff()</code>","text":"<p>Generates a crew of agents and initiates tasks based on the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>agent_file</code> <code>str</code> <p>The path to the agent file.</p> required <code>framework</code> <code>str</code> <p>The framework to be used for the agents.</p> required <code>config_list</code> <code>list</code> <p>A list of configurations for the agents.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The output of the tasks performed by the crew of agents.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified agent file does not exist.</p> <p>This function first loads the agent configuration from the specified file. It then initializes the tools required for the agents based on the specified framework. If the specified framework is \"autogen\", it loads the LLM configuration dynamically and creates an AssistantAgent for each role in the configuration. It then adds tools to the agents if specified in the configuration. Finally, it prepares tasks for the agents based on the configuration and initiates the tasks using the crew of agents. If the specified framework is not \"autogen\", it creates a crew of agents and initiates tasks based on the configuration.</p> Source code in <code>praisonai/agents_generator.py</code> <pre><code>def generate_crew_and_kickoff(self):\n    \"\"\"\n    Generates a crew of agents and initiates tasks based on the provided configuration.\n\n    Parameters:\n        agent_file (str): The path to the agent file.\n        framework (str): The framework to be used for the agents.\n        config_list (list): A list of configurations for the agents.\n\n    Returns:\n        str: The output of the tasks performed by the crew of agents.\n\n    Raises:\n        FileNotFoundError: If the specified agent file does not exist.\n\n    This function first loads the agent configuration from the specified file. It then initializes the tools required for the agents based on the specified framework. If the specified framework is \"autogen\", it loads the LLM configuration dynamically and creates an AssistantAgent for each role in the configuration. It then adds tools to the agents if specified in the configuration. Finally, it prepares tasks for the agents based on the configuration and initiates the tasks using the crew of agents. If the specified framework is not \"autogen\", it creates a crew of agents and initiates tasks based on the configuration.\n    \"\"\"\n    if self.agent_file == '/app/api:app' or self.agent_file == 'api:app':\n        self.agent_file = 'agents.yaml'\n    try:\n        with open(self.agent_file, 'r') as f:\n            config = yaml.safe_load(f)\n    except FileNotFoundError:\n        print(f\"File not found: {self.agent_file}\")\n        return\n\n    topic = config['topic']\n    tools_dict = {\n        'CodeDocsSearchTool': CodeDocsSearchTool(),\n        'CSVSearchTool': CSVSearchTool(),\n        'DirectorySearchTool': DirectorySearchTool(),\n        'DOCXSearchTool': DOCXSearchTool(),\n        'DirectoryReadTool': DirectoryReadTool(),\n        'FileReadTool': FileReadTool(),\n        # 'GithubSearchTool': GithubSearchTool(),\n        # 'SeperDevTool': SeperDevTool(),\n        'TXTSearchTool': TXTSearchTool(),\n        'JSONSearchTool': JSONSearchTool(),\n        'MDXSearchTool': MDXSearchTool(),\n        'PDFSearchTool': PDFSearchTool(),\n        # 'PGSearchTool': PGSearchTool(),\n        'RagTool': RagTool(),\n        'ScrapeElementFromWebsiteTool': ScrapeElementFromWebsiteTool(),\n        'ScrapeWebsiteTool': ScrapeWebsiteTool(),\n        'WebsiteSearchTool': WebsiteSearchTool(),\n        'XMLSearchTool': XMLSearchTool(),\n        'YoutubeChannelSearchTool': YoutubeChannelSearchTool(),\n        'YoutubeVideoSearchTool': YoutubeVideoSearchTool(),\n    }\n    root_directory = os.getcwd()\n    tools_py_path = os.path.join(root_directory, 'tools.py')\n    tools_dir_path = Path(root_directory) / 'tools'\n\n    if os.path.isfile(tools_py_path):\n        tools_dict.update(self.load_tools_from_module_class(tools_py_path))\n        # print(\"tools.py exists in the root directory. Loading tools.py and skipping tools folder.\")\n    elif tools_dir_path.is_dir():\n        tools_dict.update(self.load_tools_from_module_class(tools_dir_path))\n        # print(\"tools folder exists in the root directory\")\n\n    framework = self.framework or config.get('framework')\n\n    agents = {}\n    tasks = []\n    if framework == \"autogen\":\n        # Load the LLM configuration dynamically\n        # print(self.config_list)\n        llm_config = {\"config_list\": self.config_list}\n\n        # Assuming the user proxy agent is set up as per your requirements\n        user_proxy = autogen.UserProxyAgent(\n            name=\"User\",\n            human_input_mode=\"NEVER\",\n            is_termination_msg=lambda x: (x.get(\"content\") or \"\").rstrip().rstrip(\".\").lower().endswith(\"terminate\") or \"TERMINATE\" in (x.get(\"content\") or \"\"),\n            code_execution_config={\n                \"work_dir\": \"coding\",\n                \"use_docker\": False,\n            },\n            # additional setup for the user proxy agent\n        )\n\n        for role, details in config['roles'].items():\n            agent_name = details['role'].format(topic=topic).replace(\"{topic}\", topic)\n            agent_goal = details['goal'].format(topic=topic)\n            # Creating an AssistantAgent for each role dynamically\n            agents[role] = autogen.AssistantAgent(\n                name=agent_name,\n                llm_config=llm_config,\n                system_message=details['backstory'].format(topic=topic)+\". Must Reply \\\"TERMINATE\\\" in the end when everything is done.\",\n            )\n            for tool in details.get('tools', []):\n                if tool in tools_dict:\n                    try:\n                        tool_class = globals()[f'autogen_{type(tools_dict[tool]).__name__}']\n                        print(f\"Found {tool_class.__name__} for {tool}\")\n                    except KeyError:\n                        print(f\"Warning: autogen_{type(tools_dict[tool]).__name__} function not found. Skipping this tool.\")\n                        continue\n                    tool_class(agents[role], user_proxy)\n\n            # Preparing tasks for initiate_chats\n            for task_name, task_details in details.get('tasks', {}).items():\n                description_filled = task_details['description'].format(topic=topic)\n                expected_output_filled = task_details['expected_output'].format(topic=topic)\n\n                chat_task = {\n                    \"recipient\": agents[role],\n                    \"message\": description_filled,\n                    \"summary_method\": \"last_msg\", \n                    # Additional fields like carryover can be added based on dependencies\n                }\n                tasks.append(chat_task)\n\n        response = user_proxy.initiate_chats(tasks)\n        result = \"### Output ###\\n\"+response[-1].summary if hasattr(response[-1], 'summary') else \"\"\n    else:\n        for role, details in config['roles'].items():\n            role_filled = details['role'].format(topic=topic)\n            goal_filled = details['goal'].format(topic=topic)\n            backstory_filled = details['backstory'].format(topic=topic)\n\n            # Adding tools to the agent if exists\n            agent_tools = [tools_dict[tool] for tool in details.get('tools', []) if tool in tools_dict]\n            agent = Agent(role=role_filled, goal=goal_filled, backstory=backstory_filled, tools=agent_tools, allow_delegation=False)\n            agents[role] = agent\n\n            for task_name, task_details in details.get('tasks', {}).items():\n                description_filled = task_details['description'].format(topic=topic)\n                expected_output_filled = task_details['expected_output'].format(topic=topic)\n\n                task = Task(description=description_filled, expected_output=expected_output_filled, agent=agent)\n                tasks.append(task)\n        crew = Crew(\n            agents=list(agents.values()),\n            tasks=tasks,\n            verbose=2\n        )\n\n        response = crew.kickoff()\n        result = f\"### Task Output ###\\n{response}\"\n    return result\n</code></pre>"},{"location":"api/#praisonai.agents_generator.AgentsGenerator.is_function_or_decorated","title":"<code>is_function_or_decorated(obj)</code>","text":"<p>Checks if the given object is a function or has a call method.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to be checked.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the object is a function or has a call method, False otherwise.</p> Source code in <code>praisonai/agents_generator.py</code> <pre><code>def is_function_or_decorated(self, obj):\n    \"\"\"\n    Checks if the given object is a function or has a __call__ method.\n\n    Parameters:\n        obj (object): The object to be checked.\n\n    Returns:\n        bool: True if the object is a function or has a __call__ method, False otherwise.\n    \"\"\"\n    return inspect.isfunction(obj) or hasattr(obj, '__call__')\n</code></pre>"},{"location":"api/#praisonai.agents_generator.AgentsGenerator.load_tools_from_module","title":"<code>load_tools_from_module(module_path)</code>","text":"<p>Loads tools from a specified module path.</p> <p>Parameters:</p> Name Type Description Default <code>module_path</code> <code>str</code> <p>The path to the module containing the tools.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the names of the tools as keys and the corresponding functions or objects as values.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified module path does not exist.</p> Source code in <code>praisonai/agents_generator.py</code> <pre><code>def load_tools_from_module(self, module_path):\n    \"\"\"\n    Loads tools from a specified module path.\n\n    Parameters:\n        module_path (str): The path to the module containing the tools.\n\n    Returns:\n        dict: A dictionary containing the names of the tools as keys and the corresponding functions or objects as values.\n\n    Raises:\n        FileNotFoundError: If the specified module path does not exist.\n    \"\"\"\n    spec = importlib.util.spec_from_file_location(\"tools_module\", module_path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return {name: obj for name, obj in inspect.getmembers(module, self.is_function_or_decorated)}\n</code></pre>"},{"location":"api/#praisonai.agents_generator.AgentsGenerator.load_tools_from_module_class","title":"<code>load_tools_from_module_class(module_path)</code>","text":"<p>Loads tools from a specified module path containing classes that inherit from BaseTool or are part of langchain_community.tools package.</p> <p>Parameters:</p> Name Type Description Default <code>module_path</code> <code>str</code> <p>The path to the module containing the tools.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified module path does not exist.</p> Source code in <code>praisonai/agents_generator.py</code> <pre><code>def load_tools_from_module_class(self, module_path):\n    \"\"\"\n    Loads tools from a specified module path containing classes that inherit from BaseTool or are part of langchain_community.tools package.\n\n    Parameters:\n        module_path (str): The path to the module containing the tools.\n\n    Returns:\n        dict: A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.\n\n    Raises:\n        FileNotFoundError: If the specified module path does not exist.\n    \"\"\"\n    spec = importlib.util.spec_from_file_location(\"tools_module\", module_path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return {name: obj() for name, obj in inspect.getmembers(module, lambda x: inspect.isclass(x) and (x.__module__.startswith('langchain_community.tools') or issubclass(x, BaseTool)) and x is not BaseTool)}\n</code></pre>"},{"location":"api/#praisonai.agents_generator.AgentsGenerator.load_tools_from_package","title":"<code>load_tools_from_package(package_path)</code>","text":"<p>Loads tools from a specified package path containing modules with functions or classes.</p> <p>Parameters:</p> Name Type Description Default <code>package_path</code> <code>str</code> <p>The path to the package containing the tools.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified package path does not exist.</p> <p>This function iterates through all the .py files in the specified package path, excluding those that start with \"__\". For each file, it imports the corresponding module and checks if it contains any functions or classes that can be loaded as tools. The function then returns a dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.</p> Source code in <code>praisonai/agents_generator.py</code> <pre><code>def load_tools_from_package(self, package_path):\n    \"\"\"\n    Loads tools from a specified package path containing modules with functions or classes.\n\n    Parameters:\n        package_path (str): The path to the package containing the tools.\n\n    Returns:\n        dict: A dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.\n\n    Raises:\n        FileNotFoundError: If the specified package path does not exist.\n\n    This function iterates through all the .py files in the specified package path, excluding those that start with \"__\". For each file, it imports the corresponding module and checks if it contains any functions or classes that can be loaded as tools. The function then returns a dictionary containing the names of the tools as keys and the corresponding initialized instances of the classes as values.\n    \"\"\"\n    tools_dict = {}\n    for module_file in os.listdir(package_path):\n        if module_file.endswith('.py') and not module_file.startswith('__'):\n            module_name = f\"{package_path.name}.{module_file[:-3]}\"  # Remove .py for import\n            module = importlib.import_module(module_name)\n            for name, obj in inspect.getmembers(module, self.is_function_or_decorated):\n                tools_dict[name] = obj\n    return tools_dict\n</code></pre>"},{"location":"api/#praisonai.cli.PraisonAI","title":"<code>PraisonAI</code>","text":"Source code in <code>praisonai/cli.py</code> <pre><code>class PraisonAI:\n    def __init__(self, agent_file=\"agents.yaml\", framework=\"\", auto=False, init=False):\n        \"\"\"\n        Initialize the PraisonAI object with default parameters.\n\n        Parameters:\n            agent_file (str): The default agent file to use. Defaults to \"agents.yaml\".\n            framework (str): The default framework to use. Defaults to \"crewai\".\n            auto (bool): A flag indicating whether to enable auto mode. Defaults to False.\n            init (bool): A flag indicating whether to enable initialization mode. Defaults to False.\n\n        Attributes:\n            config_list (list): A list of configuration dictionaries for the OpenAI API.\n            agent_file (str): The agent file to use.\n            framework (str): The framework to use.\n            auto (bool): A flag indicating whether to enable auto mode.\n            init (bool): A flag indicating whether to enable initialization mode.\n        \"\"\"\n        self.config_list = [\n            {\n                'model': os.environ.get(\"OPENAI_MODEL_NAME\", \"gpt-4o\"),\n                'base_url': os.environ.get(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\"),\n            }\n        ]\n        self.agent_file = agent_file\n        self.framework = framework\n        self.auto = auto\n        self.init = init\n\n    def main(self):\n        \"\"\"\n        The main function of the PraisonAI object. It parses the command-line arguments,\n        initializes the necessary attributes, and then calls the appropriate methods based on the\n        provided arguments.\n\n        Args:\n            self (PraisonAI): An instance of the PraisonAI class.\n\n        Returns:\n            Any: Depending on the arguments provided, the function may return a result from the\n            AgentsGenerator, a deployment result from the CloudDeployer, or a message indicating\n            the successful creation of a file.\n        \"\"\"\n        args = self.parse_args()\n        if args is None:\n            agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n            result = agents_generator.generate_crew_and_kickoff()\n            return result\n        if args.deploy:\n            from .deploy import CloudDeployer\n            deployer = CloudDeployer()\n            deployer.run_commands()\n            return\n        invocation_cmd = \"praisonai\"\n        version_string = f\"PraisonAI version {__version__}\"\n\n        self.framework = args.framework or self.framework \n\n        if args.agent_file:\n            if args.agent_file.startswith(\"tests.test\"): # Argument used for testing purposes. eg: python -m unittest tests.test \n                print(\"test\")\n            else:\n                self.agent_file = args.agent_file\n\n\n        if args.auto or args.init:\n            temp_topic = ' '.join(args.auto) if args.auto else ' '.join(args.init)\n            self.topic = temp_topic\n        elif self.auto or self.init:  # Use the auto attribute if args.auto is not provided\n            self.topic = self.auto\n\n        if args.auto or self.auto:\n            self.agent_file = \"test.yaml\"\n            generator = AutoGenerator(topic=self.topic , framework=self.framework, agent_file=self.agent_file)\n            self.agent_file = generator.generate()\n            agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n            result = agents_generator.generate_crew_and_kickoff()\n            return result\n        elif args.init or self.init:\n            self.agent_file = \"agents.yaml\"\n            generator = AutoGenerator(topic=self.topic , framework=self.framework, agent_file=self.agent_file)\n            self.agent_file = generator.generate()\n            print(\"File {} created successfully\".format(self.agent_file))\n            return \"File {} created successfully\".format(self.agent_file)\n\n        if args.ui:\n            if args.ui == \"gradio\":\n                self.create_gradio_interface()\n            elif args.ui == \"chainlit\":\n                self.create_chainlit_interface()\n            else:\n                # Modify below code to allow default ui\n                agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n                result = agents_generator.generate_crew_and_kickoff()\n                return result\n        else:\n            agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n            result = agents_generator.generate_crew_and_kickoff()\n            return result\n\n    def parse_args(self):\n        \"\"\"\n        Parse the command-line arguments for the PraisonAI CLI.\n\n        Args:\n            self (PraisonAI): An instance of the PraisonAI class.\n\n        Returns:\n            argparse.Namespace: An object containing the parsed command-line arguments.\n\n        Raises:\n            argparse.ArgumentError: If the arguments provided are invalid.\n\n        Example:\n            &gt;&gt;&gt; args = praison_ai.parse_args()\n            &gt;&gt;&gt; print(args.agent_file)  # Output: 'agents.yaml'\n        \"\"\"\n        parser = argparse.ArgumentParser(prog=\"praisonai\", description=\"praisonAI command-line interface\")\n        parser.add_argument(\"--framework\", choices=[\"crewai\", \"autogen\"], help=\"Specify the framework\")\n        parser.add_argument(\"--ui\", choices=[\"chainlit\", \"gradio\"], help=\"Specify the UI framework (gradio or chainlit).\")\n        parser.add_argument(\"--auto\", nargs=argparse.REMAINDER, help=\"Enable auto mode and pass arguments for it\")\n        parser.add_argument(\"--init\", nargs=argparse.REMAINDER, help=\"Enable auto mode and pass arguments for it\")\n        parser.add_argument(\"agent_file\", nargs=\"?\", help=\"Specify the agent file\")\n        parser.add_argument(\"--deploy\", action=\"store_true\", help=\"Deploy the application\")  # New argument\n        args, unknown_args = parser.parse_known_args()\n\n        if unknown_args and unknown_args[0] == '-b' and unknown_args[1] == 'api:app':\n            args.agent_file = 'agents.yaml'\n        if args.agent_file == 'api:app' or args.agent_file == '/app/api:app':\n            args.agent_file = 'agents.yaml'\n\n        return args\n\n    def create_gradio_interface(self):\n        \"\"\"\n        Create a Gradio interface for generating agents and performing tasks.\n\n        Args:\n            self (PraisonAI): An instance of the PraisonAI class.\n\n        Returns:\n            None: This method does not return any value. It launches the Gradio interface.\n\n        Raises:\n            None: This method does not raise any exceptions.\n\n        Example:\n            &gt;&gt;&gt; praison_ai.create_gradio_interface()\n        \"\"\"\n        if GRADIO_AVAILABLE:\n            def generate_crew_and_kickoff_interface(auto_args, framework):\n                \"\"\"\n                Generate a crew and kick off tasks based on the provided auto arguments and framework.\n\n                Args:\n                    auto_args (list): Topic.\n                    framework (str): The framework to use for generating agents.\n\n                Returns:\n                    str: A string representing the result of generating the crew and kicking off tasks.\n\n                Raises:\n                    None: This method does not raise any exceptions.\n\n                Example:\n                    &gt;&gt;&gt; result = generate_crew_and_kickoff_interface(\"Create a movie about Cat in Mars\", \"crewai\")\n                    &gt;&gt;&gt; print(result)\n                \"\"\"\n                self.framework = framework\n                self.agent_file = \"test.yaml\"\n                generator = AutoGenerator(topic=auto_args , framework=self.framework)\n                self.agent_file = generator.generate()\n                agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n                result = agents_generator.generate_crew_and_kickoff()\n                return result\n\n            gr.Interface(\n                fn=generate_crew_and_kickoff_interface,\n                inputs=[gr.Textbox(lines=2, label=\"Auto Args\"), gr.Dropdown(choices=[\"crewai\", \"autogen\"], label=\"Framework\")],\n                outputs=\"textbox\",\n                title=\"Praison AI Studio\",\n                description=\"Create Agents and perform tasks\",\n                theme=\"default\"\n            ).launch()\n        else:\n            print(\"ERROR: Gradio is not installed. Please install it with 'pip install \\\"praisonai[gradio]\\\"' to use this feature.\") \n\n    def create_chainlit_interface(self):\n        \"\"\"\n        Create a Chainlit interface for generating agents and performing tasks.\n\n        This function sets up a Chainlit application that listens for messages.\n        When a message is received, it runs PraisonAI with the provided message as the topic.\n        The generated agents are then used to perform tasks.\n\n        Returns:\n            None: This function does not return any value. It starts the Chainlit application.\n        \"\"\"\n        if CHAINLIT_AVAILABLE:\n            os.environ[\"CHAINLIT_PORT\"] = \"8082\"  \n            chainlit_run([\"praisonai/chainlit_ui.py\"])  \n        else:\n            print(\"ERROR: Chainlit is not installed. Please install it with 'pip install \\\"praisonai\\[ui]\\\"' to use the UI.\")        \n</code></pre>"},{"location":"api/#praisonai.cli.PraisonAI.__init__","title":"<code>__init__(agent_file='agents.yaml', framework='', auto=False, init=False)</code>","text":"<p>Initialize the PraisonAI object with default parameters.</p> <p>Parameters:</p> Name Type Description Default <code>agent_file</code> <code>str</code> <p>The default agent file to use. Defaults to \"agents.yaml\".</p> <code>'agents.yaml'</code> <code>framework</code> <code>str</code> <p>The default framework to use. Defaults to \"crewai\".</p> <code>''</code> <code>auto</code> <code>bool</code> <p>A flag indicating whether to enable auto mode. Defaults to False.</p> <code>False</code> <code>init</code> <code>bool</code> <p>A flag indicating whether to enable initialization mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>config_list</code> <code>list</code> <p>A list of configuration dictionaries for the OpenAI API.</p> <code>agent_file</code> <code>str</code> <p>The agent file to use.</p> <code>framework</code> <code>str</code> <p>The framework to use.</p> <code>auto</code> <code>bool</code> <p>A flag indicating whether to enable auto mode.</p> <code>init</code> <code>bool</code> <p>A flag indicating whether to enable initialization mode.</p> Source code in <code>praisonai/cli.py</code> <pre><code>def __init__(self, agent_file=\"agents.yaml\", framework=\"\", auto=False, init=False):\n    \"\"\"\n    Initialize the PraisonAI object with default parameters.\n\n    Parameters:\n        agent_file (str): The default agent file to use. Defaults to \"agents.yaml\".\n        framework (str): The default framework to use. Defaults to \"crewai\".\n        auto (bool): A flag indicating whether to enable auto mode. Defaults to False.\n        init (bool): A flag indicating whether to enable initialization mode. Defaults to False.\n\n    Attributes:\n        config_list (list): A list of configuration dictionaries for the OpenAI API.\n        agent_file (str): The agent file to use.\n        framework (str): The framework to use.\n        auto (bool): A flag indicating whether to enable auto mode.\n        init (bool): A flag indicating whether to enable initialization mode.\n    \"\"\"\n    self.config_list = [\n        {\n            'model': os.environ.get(\"OPENAI_MODEL_NAME\", \"gpt-4o\"),\n            'base_url': os.environ.get(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\"),\n        }\n    ]\n    self.agent_file = agent_file\n    self.framework = framework\n    self.auto = auto\n    self.init = init\n</code></pre>"},{"location":"api/#praisonai.cli.PraisonAI.create_chainlit_interface","title":"<code>create_chainlit_interface()</code>","text":"<p>Create a Chainlit interface for generating agents and performing tasks.</p> <p>This function sets up a Chainlit application that listens for messages. When a message is received, it runs PraisonAI with the provided message as the topic. The generated agents are then used to perform tasks.</p> <p>Returns:</p> Name Type Description <code>None</code> <p>This function does not return any value. It starts the Chainlit application.</p> Source code in <code>praisonai/cli.py</code> <pre><code>def create_chainlit_interface(self):\n    \"\"\"\n    Create a Chainlit interface for generating agents and performing tasks.\n\n    This function sets up a Chainlit application that listens for messages.\n    When a message is received, it runs PraisonAI with the provided message as the topic.\n    The generated agents are then used to perform tasks.\n\n    Returns:\n        None: This function does not return any value. It starts the Chainlit application.\n    \"\"\"\n    if CHAINLIT_AVAILABLE:\n        os.environ[\"CHAINLIT_PORT\"] = \"8082\"  \n        chainlit_run([\"praisonai/chainlit_ui.py\"])  \n    else:\n        print(\"ERROR: Chainlit is not installed. Please install it with 'pip install \\\"praisonai\\[ui]\\\"' to use the UI.\")        \n</code></pre>"},{"location":"api/#praisonai.cli.PraisonAI.create_gradio_interface","title":"<code>create_gradio_interface()</code>","text":"<p>Create a Gradio interface for generating agents and performing tasks.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>PraisonAI</code> <p>An instance of the PraisonAI class.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>This method does not return any value. It launches the Gradio interface.</p> <p>Raises:</p> Type Description <code>None</code> <p>This method does not raise any exceptions.</p> Example <p>praison_ai.create_gradio_interface()</p> Source code in <code>praisonai/cli.py</code> <pre><code>def create_gradio_interface(self):\n    \"\"\"\n    Create a Gradio interface for generating agents and performing tasks.\n\n    Args:\n        self (PraisonAI): An instance of the PraisonAI class.\n\n    Returns:\n        None: This method does not return any value. It launches the Gradio interface.\n\n    Raises:\n        None: This method does not raise any exceptions.\n\n    Example:\n        &gt;&gt;&gt; praison_ai.create_gradio_interface()\n    \"\"\"\n    if GRADIO_AVAILABLE:\n        def generate_crew_and_kickoff_interface(auto_args, framework):\n            \"\"\"\n            Generate a crew and kick off tasks based on the provided auto arguments and framework.\n\n            Args:\n                auto_args (list): Topic.\n                framework (str): The framework to use for generating agents.\n\n            Returns:\n                str: A string representing the result of generating the crew and kicking off tasks.\n\n            Raises:\n                None: This method does not raise any exceptions.\n\n            Example:\n                &gt;&gt;&gt; result = generate_crew_and_kickoff_interface(\"Create a movie about Cat in Mars\", \"crewai\")\n                &gt;&gt;&gt; print(result)\n            \"\"\"\n            self.framework = framework\n            self.agent_file = \"test.yaml\"\n            generator = AutoGenerator(topic=auto_args , framework=self.framework)\n            self.agent_file = generator.generate()\n            agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n            result = agents_generator.generate_crew_and_kickoff()\n            return result\n\n        gr.Interface(\n            fn=generate_crew_and_kickoff_interface,\n            inputs=[gr.Textbox(lines=2, label=\"Auto Args\"), gr.Dropdown(choices=[\"crewai\", \"autogen\"], label=\"Framework\")],\n            outputs=\"textbox\",\n            title=\"Praison AI Studio\",\n            description=\"Create Agents and perform tasks\",\n            theme=\"default\"\n        ).launch()\n    else:\n        print(\"ERROR: Gradio is not installed. Please install it with 'pip install \\\"praisonai[gradio]\\\"' to use this feature.\") \n</code></pre>"},{"location":"api/#praisonai.cli.PraisonAI.main","title":"<code>main()</code>","text":"<p>The main function of the PraisonAI object. It parses the command-line arguments, initializes the necessary attributes, and then calls the appropriate methods based on the provided arguments.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>PraisonAI</code> <p>An instance of the PraisonAI class.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Depending on the arguments provided, the function may return a result from the</p> <p>AgentsGenerator, a deployment result from the CloudDeployer, or a message indicating</p> <p>the successful creation of a file.</p> Source code in <code>praisonai/cli.py</code> <pre><code>def main(self):\n    \"\"\"\n    The main function of the PraisonAI object. It parses the command-line arguments,\n    initializes the necessary attributes, and then calls the appropriate methods based on the\n    provided arguments.\n\n    Args:\n        self (PraisonAI): An instance of the PraisonAI class.\n\n    Returns:\n        Any: Depending on the arguments provided, the function may return a result from the\n        AgentsGenerator, a deployment result from the CloudDeployer, or a message indicating\n        the successful creation of a file.\n    \"\"\"\n    args = self.parse_args()\n    if args is None:\n        agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n        result = agents_generator.generate_crew_and_kickoff()\n        return result\n    if args.deploy:\n        from .deploy import CloudDeployer\n        deployer = CloudDeployer()\n        deployer.run_commands()\n        return\n    invocation_cmd = \"praisonai\"\n    version_string = f\"PraisonAI version {__version__}\"\n\n    self.framework = args.framework or self.framework \n\n    if args.agent_file:\n        if args.agent_file.startswith(\"tests.test\"): # Argument used for testing purposes. eg: python -m unittest tests.test \n            print(\"test\")\n        else:\n            self.agent_file = args.agent_file\n\n\n    if args.auto or args.init:\n        temp_topic = ' '.join(args.auto) if args.auto else ' '.join(args.init)\n        self.topic = temp_topic\n    elif self.auto or self.init:  # Use the auto attribute if args.auto is not provided\n        self.topic = self.auto\n\n    if args.auto or self.auto:\n        self.agent_file = \"test.yaml\"\n        generator = AutoGenerator(topic=self.topic , framework=self.framework, agent_file=self.agent_file)\n        self.agent_file = generator.generate()\n        agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n        result = agents_generator.generate_crew_and_kickoff()\n        return result\n    elif args.init or self.init:\n        self.agent_file = \"agents.yaml\"\n        generator = AutoGenerator(topic=self.topic , framework=self.framework, agent_file=self.agent_file)\n        self.agent_file = generator.generate()\n        print(\"File {} created successfully\".format(self.agent_file))\n        return \"File {} created successfully\".format(self.agent_file)\n\n    if args.ui:\n        if args.ui == \"gradio\":\n            self.create_gradio_interface()\n        elif args.ui == \"chainlit\":\n            self.create_chainlit_interface()\n        else:\n            # Modify below code to allow default ui\n            agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n            result = agents_generator.generate_crew_and_kickoff()\n            return result\n    else:\n        agents_generator = AgentsGenerator(self.agent_file, self.framework, self.config_list)\n        result = agents_generator.generate_crew_and_kickoff()\n        return result\n</code></pre>"},{"location":"api/#praisonai.cli.PraisonAI.parse_args","title":"<code>parse_args()</code>","text":"<p>Parse the command-line arguments for the PraisonAI CLI.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>PraisonAI</code> <p>An instance of the PraisonAI class.</p> required <p>Returns:</p> Type Description <p>argparse.Namespace: An object containing the parsed command-line arguments.</p> <p>Raises:</p> Type Description <code>ArgumentError</code> <p>If the arguments provided are invalid.</p> Example <p>args = praison_ai.parse_args() print(args.agent_file)  # Output: 'agents.yaml'</p> Source code in <code>praisonai/cli.py</code> <pre><code>def parse_args(self):\n    \"\"\"\n    Parse the command-line arguments for the PraisonAI CLI.\n\n    Args:\n        self (PraisonAI): An instance of the PraisonAI class.\n\n    Returns:\n        argparse.Namespace: An object containing the parsed command-line arguments.\n\n    Raises:\n        argparse.ArgumentError: If the arguments provided are invalid.\n\n    Example:\n        &gt;&gt;&gt; args = praison_ai.parse_args()\n        &gt;&gt;&gt; print(args.agent_file)  # Output: 'agents.yaml'\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=\"praisonai\", description=\"praisonAI command-line interface\")\n    parser.add_argument(\"--framework\", choices=[\"crewai\", \"autogen\"], help=\"Specify the framework\")\n    parser.add_argument(\"--ui\", choices=[\"chainlit\", \"gradio\"], help=\"Specify the UI framework (gradio or chainlit).\")\n    parser.add_argument(\"--auto\", nargs=argparse.REMAINDER, help=\"Enable auto mode and pass arguments for it\")\n    parser.add_argument(\"--init\", nargs=argparse.REMAINDER, help=\"Enable auto mode and pass arguments for it\")\n    parser.add_argument(\"agent_file\", nargs=\"?\", help=\"Specify the agent file\")\n    parser.add_argument(\"--deploy\", action=\"store_true\", help=\"Deploy the application\")  # New argument\n    args, unknown_args = parser.parse_known_args()\n\n    if unknown_args and unknown_args[0] == '-b' and unknown_args[1] == 'api:app':\n        args.agent_file = 'agents.yaml'\n    if args.agent_file == 'api:app' or args.agent_file == '/app/api:app':\n        args.agent_file = 'agents.yaml'\n\n    return args\n</code></pre>"},{"location":"api/#praisonai.deploy.CloudDeployer","title":"<code>CloudDeployer</code>","text":"<p>A class for deploying a cloud-based application.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Loads environment variables from .env file or system and sets them.</p> Source code in <code>praisonai/deploy.py</code> <pre><code>class CloudDeployer:\n    \"\"\"\n    A class for deploying a cloud-based application.\n\n    Attributes:\n        None\n\n    Methods:\n        __init__(self):\n            Loads environment variables from .env file or system and sets them.\n\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Loads environment variables from .env file or system and sets them.\n\n        Parameters:\n            self: An instance of the CloudDeployer class.\n\n        Returns:\n            None\n\n        Raises:\n            None\n\n        \"\"\"\n        # Load environment variables from .env file or system\n        load_dotenv()\n        self.set_environment_variables()\n\n    def create_dockerfile(self):\n        \"\"\"\n        Creates a Dockerfile for the application.\n\n        Parameters:\n            self: An instance of the CloudDeployer class.\n\n        Returns:\n            None\n\n        Raises:\n            None\n\n        This method creates a Dockerfile in the current directory with the specified content.\n        The Dockerfile is used to build a Docker image for the application.\n        The content of the Dockerfile includes instructions to use the Python 3.11-slim base image,\n        set the working directory to /app, copy the current directory contents into the container,\n        install the required Python packages (flask, praisonai, gunicorn, and markdown),\n        expose port 8080, and run the application using Gunicorn.\n        \"\"\"\n        with open(\"Dockerfile\", \"w\") as file:\n            file.write(\"FROM python:3.11-slim\\n\")\n            file.write(\"WORKDIR /app\\n\")\n            file.write(\"COPY . .\\n\")\n            file.write(\"RUN pip install flask praisonai==0.0.24 gunicorn markdown\\n\")\n            file.write(\"EXPOSE 8080\\n\")\n            file.write('CMD [\"gunicorn\", \"-b\", \"0.0.0.0:8080\", \"api:app\"]\\n')\n\n    def create_api_file(self):\n        \"\"\"\n        Creates an API file for the application.\n\n        Parameters:\n            self (CloudDeployer): An instance of the CloudDeployer class.\n\n        Returns:\n            None\n\n        This method creates an API file named \"api.py\" in the current directory. The file contains a basic Flask application that uses the PraisonAI library to run a simple agent and returns the output as an HTML page. The application listens on the root path (\"/\") and uses the Markdown library to format the output.\n        \"\"\"\n        with open(\"api.py\", \"w\") as file:\n            file.write(\"from flask import Flask\\n\")\n            file.write(\"from praisonai import PraisonAI\\n\")\n            file.write(\"import markdown\\n\\n\")\n            file.write(\"app = Flask(__name__)\\n\\n\")\n            file.write(\"def basic():\\n\")\n            file.write(\"    praison_ai = PraisonAI(agent_file=\\\"agents.yaml\\\")\\n\")\n            file.write(\"    return praison_ai.main()\\n\\n\")\n            file.write(\"@app.route('/')\\n\")\n            file.write(\"def home():\\n\")\n            file.write(\"    output = basic()\\n\")\n            file.write(\"    html_output = markdown.markdown(output)\\n\")\n            file.write(\"    return f'&lt;html&gt;&lt;body&gt;{html_output}&lt;/body&gt;&lt;/html&gt;'\\n\\n\")\n            file.write(\"if __name__ == \\\"__main__\\\":\\n\")\n            file.write(\"    app.run(debug=True)\\n\")\n\n    def set_environment_variables(self):\n        \"\"\"Sets environment variables with fallback to .env values or defaults.\"\"\"\n        os.environ[\"OPENAI_MODEL_NAME\"] = os.getenv(\"OPENAI_MODEL_NAME\", \"gpt-4o\")\n        os.environ[\"OPENAI_API_KEY\"] = os.getenv(\"OPENAI_API_KEY\", \"Enter your API key\")\n        os.environ[\"OPENAI_API_BASE\"] = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n\n    def run_commands(self):\n        \"\"\"\n        Sets environment variables with fallback to .env values or defaults.\n\n        Parameters:\n            None\n\n        Returns:\n            None\n\n        Raises:\n            None\n\n        This method sets environment variables for the application. It uses the `os.environ` dictionary to set the following environment variables:\n\n        - `OPENAI_MODEL_NAME`: The name of the OpenAI model to use. If not specified in the .env file, it defaults to \"gpt-4o\".\n        - `OPENAI_API_KEY`: The API key for accessing the OpenAI API. If not specified in the .env file, it defaults to \"Enter your API key\".\n        - `OPENAI_API_BASE`: The base URL for the OpenAI API. If not specified in the .env file, it defaults to \"https://api.openai.com/v1\".\n        \"\"\"\n        self.create_api_file()\n        self.create_dockerfile()\n        \"\"\"Runs a sequence of shell commands for deployment, continues on error.\"\"\"\n        commands = [\n            \"yes | gcloud auth configure-docker us-central1-docker.pkg.dev\",\n            \"gcloud artifacts repositories create praisonai-repository --repository-format=docker --location=us-central1\",\n            \"docker build --platform linux/amd64 -t gcr.io/$(gcloud config get-value project)/praisonai-app:latest .\",\n            \"docker tag gcr.io/$(gcloud config get-value project)/praisonai-app:latest us-central1-docker.pkg.dev/$(gcloud config get-value project)/praisonai-repository/praisonai-app:latest\",\n            \"docker push us-central1-docker.pkg.dev/$(gcloud config get-value project)/praisonai-repository/praisonai-app:latest\",\n            \"gcloud run deploy praisonai-service --image us-central1-docker.pkg.dev/$(gcloud config get-value project)/praisonai-repository/praisonai-app:latest --platform managed --region us-central1 --allow-unauthenticated --set-env-vars OPENAI_MODEL_NAME=${OPENAI_MODEL_NAME},OPENAI_API_KEY=${OPENAI_API_KEY},OPENAI_API_BASE=${OPENAI_API_BASE}\"\n        ]\n\n        for cmd in commands:\n            try:\n                subprocess.run(cmd, shell=True, check=True)\n            except subprocess.CalledProcessError as e:\n                print(f\"ERROR: Command '{e.cmd}' failed with exit status {e.returncode}\")\n                print(f\"Continuing with the next command...\")\n</code></pre>"},{"location":"api/#praisonai.deploy.CloudDeployer.__init__","title":"<code>__init__()</code>","text":"<p>Loads environment variables from .env file or system and sets them.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>An instance of the CloudDeployer class.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>praisonai/deploy.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Loads environment variables from .env file or system and sets them.\n\n    Parameters:\n        self: An instance of the CloudDeployer class.\n\n    Returns:\n        None\n\n    Raises:\n        None\n\n    \"\"\"\n    # Load environment variables from .env file or system\n    load_dotenv()\n    self.set_environment_variables()\n</code></pre>"},{"location":"api/#praisonai.deploy.CloudDeployer.create_api_file","title":"<code>create_api_file()</code>","text":"<p>Creates an API file for the application.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>CloudDeployer</code> <p>An instance of the CloudDeployer class.</p> required <p>Returns:</p> Type Description <p>None</p> <p>This method creates an API file named \"api.py\" in the current directory. The file contains a basic Flask application that uses the PraisonAI library to run a simple agent and returns the output as an HTML page. The application listens on the root path (\"/\") and uses the Markdown library to format the output.</p> Source code in <code>praisonai/deploy.py</code> <pre><code>def create_api_file(self):\n    \"\"\"\n    Creates an API file for the application.\n\n    Parameters:\n        self (CloudDeployer): An instance of the CloudDeployer class.\n\n    Returns:\n        None\n\n    This method creates an API file named \"api.py\" in the current directory. The file contains a basic Flask application that uses the PraisonAI library to run a simple agent and returns the output as an HTML page. The application listens on the root path (\"/\") and uses the Markdown library to format the output.\n    \"\"\"\n    with open(\"api.py\", \"w\") as file:\n        file.write(\"from flask import Flask\\n\")\n        file.write(\"from praisonai import PraisonAI\\n\")\n        file.write(\"import markdown\\n\\n\")\n        file.write(\"app = Flask(__name__)\\n\\n\")\n        file.write(\"def basic():\\n\")\n        file.write(\"    praison_ai = PraisonAI(agent_file=\\\"agents.yaml\\\")\\n\")\n        file.write(\"    return praison_ai.main()\\n\\n\")\n        file.write(\"@app.route('/')\\n\")\n        file.write(\"def home():\\n\")\n        file.write(\"    output = basic()\\n\")\n        file.write(\"    html_output = markdown.markdown(output)\\n\")\n        file.write(\"    return f'&lt;html&gt;&lt;body&gt;{html_output}&lt;/body&gt;&lt;/html&gt;'\\n\\n\")\n        file.write(\"if __name__ == \\\"__main__\\\":\\n\")\n        file.write(\"    app.run(debug=True)\\n\")\n</code></pre>"},{"location":"api/#praisonai.deploy.CloudDeployer.create_dockerfile","title":"<code>create_dockerfile()</code>","text":"<p>Creates a Dockerfile for the application.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>An instance of the CloudDeployer class.</p> required <p>Returns:</p> Type Description <p>None</p> <p>This method creates a Dockerfile in the current directory with the specified content. The Dockerfile is used to build a Docker image for the application. The content of the Dockerfile includes instructions to use the Python 3.11-slim base image, set the working directory to /app, copy the current directory contents into the container, install the required Python packages (flask, praisonai, gunicorn, and markdown), expose port 8080, and run the application using Gunicorn.</p> Source code in <code>praisonai/deploy.py</code> <pre><code>def create_dockerfile(self):\n    \"\"\"\n    Creates a Dockerfile for the application.\n\n    Parameters:\n        self: An instance of the CloudDeployer class.\n\n    Returns:\n        None\n\n    Raises:\n        None\n\n    This method creates a Dockerfile in the current directory with the specified content.\n    The Dockerfile is used to build a Docker image for the application.\n    The content of the Dockerfile includes instructions to use the Python 3.11-slim base image,\n    set the working directory to /app, copy the current directory contents into the container,\n    install the required Python packages (flask, praisonai, gunicorn, and markdown),\n    expose port 8080, and run the application using Gunicorn.\n    \"\"\"\n    with open(\"Dockerfile\", \"w\") as file:\n        file.write(\"FROM python:3.11-slim\\n\")\n        file.write(\"WORKDIR /app\\n\")\n        file.write(\"COPY . .\\n\")\n        file.write(\"RUN pip install flask praisonai==0.0.24 gunicorn markdown\\n\")\n        file.write(\"EXPOSE 8080\\n\")\n        file.write('CMD [\"gunicorn\", \"-b\", \"0.0.0.0:8080\", \"api:app\"]\\n')\n</code></pre>"},{"location":"api/#praisonai.deploy.CloudDeployer.run_commands","title":"<code>run_commands()</code>","text":"<p>Sets environment variables with fallback to .env values or defaults.</p> <p>Returns:</p> Type Description <p>None</p> <p>This method sets environment variables for the application. It uses the <code>os.environ</code> dictionary to set the following environment variables:</p> <ul> <li><code>OPENAI_MODEL_NAME</code>: The name of the OpenAI model to use. If not specified in the .env file, it defaults to \"gpt-4o\".</li> <li><code>OPENAI_API_KEY</code>: The API key for accessing the OpenAI API. If not specified in the .env file, it defaults to \"Enter your API key\".</li> <li><code>OPENAI_API_BASE</code>: The base URL for the OpenAI API. If not specified in the .env file, it defaults to \"https://api.openai.com/v1\".</li> </ul> Source code in <code>praisonai/deploy.py</code> <pre><code>def run_commands(self):\n    \"\"\"\n    Sets environment variables with fallback to .env values or defaults.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n\n    Raises:\n        None\n\n    This method sets environment variables for the application. It uses the `os.environ` dictionary to set the following environment variables:\n\n    - `OPENAI_MODEL_NAME`: The name of the OpenAI model to use. If not specified in the .env file, it defaults to \"gpt-4o\".\n    - `OPENAI_API_KEY`: The API key for accessing the OpenAI API. If not specified in the .env file, it defaults to \"Enter your API key\".\n    - `OPENAI_API_BASE`: The base URL for the OpenAI API. If not specified in the .env file, it defaults to \"https://api.openai.com/v1\".\n    \"\"\"\n    self.create_api_file()\n    self.create_dockerfile()\n    \"\"\"Runs a sequence of shell commands for deployment, continues on error.\"\"\"\n    commands = [\n        \"yes | gcloud auth configure-docker us-central1-docker.pkg.dev\",\n        \"gcloud artifacts repositories create praisonai-repository --repository-format=docker --location=us-central1\",\n        \"docker build --platform linux/amd64 -t gcr.io/$(gcloud config get-value project)/praisonai-app:latest .\",\n        \"docker tag gcr.io/$(gcloud config get-value project)/praisonai-app:latest us-central1-docker.pkg.dev/$(gcloud config get-value project)/praisonai-repository/praisonai-app:latest\",\n        \"docker push us-central1-docker.pkg.dev/$(gcloud config get-value project)/praisonai-repository/praisonai-app:latest\",\n        \"gcloud run deploy praisonai-service --image us-central1-docker.pkg.dev/$(gcloud config get-value project)/praisonai-repository/praisonai-app:latest --platform managed --region us-central1 --allow-unauthenticated --set-env-vars OPENAI_MODEL_NAME=${OPENAI_MODEL_NAME},OPENAI_API_KEY=${OPENAI_API_KEY},OPENAI_API_BASE=${OPENAI_API_BASE}\"\n    ]\n\n    for cmd in commands:\n        try:\n            subprocess.run(cmd, shell=True, check=True)\n        except subprocess.CalledProcessError as e:\n            print(f\"ERROR: Command '{e.cmd}' failed with exit status {e.returncode}\")\n            print(f\"Continuing with the next command...\")\n</code></pre>"},{"location":"api/#praisonai.deploy.CloudDeployer.set_environment_variables","title":"<code>set_environment_variables()</code>","text":"<p>Sets environment variables with fallback to .env values or defaults.</p> Source code in <code>praisonai/deploy.py</code> <pre><code>def set_environment_variables(self):\n    \"\"\"Sets environment variables with fallback to .env values or defaults.\"\"\"\n    os.environ[\"OPENAI_MODEL_NAME\"] = os.getenv(\"OPENAI_MODEL_NAME\", \"gpt-4o\")\n    os.environ[\"OPENAI_API_KEY\"] = os.getenv(\"OPENAI_API_KEY\", \"Enter your API key\")\n    os.environ[\"OPENAI_API_BASE\"] = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n</code></pre>"},{"location":"auto/","title":"Auto","text":""},{"location":"auto/#full-automatic-mode","title":"Full Automatic Mode","text":"<pre><code>praisonai --auto create a movie script about Dog in Moon\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<ul> <li>Fork on GitHub: Use the \"Fork\" button on the repository page.</li> <li>Clone your fork: <code>git clone https://github.com/yourusername/praisonAI.git</code></li> <li>Create a branch: <code>git checkout -b new-feature</code></li> <li>Make changes and commit: <code>git commit -am \"Add some feature\"</code></li> <li>Push to your fork: <code>git push origin new-feature</code></li> <li>Submit a pull request via GitHub's web interface.</li> <li>Await feedback from project maintainers.</li> </ul>"},{"location":"create_custom_tools/","title":"Create Custom Tools","text":""},{"location":"create_custom_tools/#tldr-to-create-a-custom-tool","title":"TL;DR to Create a Custom Tool","text":"<pre><code>pip install praisonai duckduckgo-search\nexport OPENAI_API_KEY=\"Enter your API key\"\npraisonai --init research about the latest AI News and prepare a detailed report\n</code></pre> <ul> <li>Add <code>- InternetSearchTool</code> in the agents.yaml file in the tools section. </li> <li>Create a file called tools.py and add this code tools.py</li> </ul> <pre><code>praisonai\n</code></pre>"},{"location":"create_custom_tools/#pre-requisite-to-create-a-custom-tool","title":"Pre-requisite to Create a Custom Tool","text":"<p><code>agents.yaml</code> file should be present in the current directory. </p> <p>If it doesn't exist, create it by running the command <code>praisonai --init research about the latest AI News and prepare a detailed report</code>.</p>"},{"location":"create_custom_tools/#step-1-to-create-a-custom-tool","title":"Step 1 to Create a Custom Tool","text":"<p>Create a file called tools.py in the same directory as the agents.yaml file.</p> <pre><code># example tools.py\nfrom duckduckgo_search import DDGS\nfrom praisonai_tools import BaseTool\n\nclass InternetSearchTool(BaseTool):\n    name: str = \"InternetSearchTool\"\n    description: str = \"Search Internet for relevant information based on a query or latest news\"\n\n    def _run(self, query: str):\n        ddgs = DDGS()\n        results = ddgs.text(keywords=query, region='wt-wt', safesearch='moderate', max_results=5)\n        return results\n</code></pre>"},{"location":"create_custom_tools/#step-2-to-create-a-custom-tool","title":"Step 2 to Create a Custom Tool","text":"<p>Add the tool to the agents.yaml file as show below under the tools section <code>- InternetSearchTool</code>.</p> <pre><code>framework: crewai\ntopic: research about the latest AI News and prepare a detailed report\nroles:\n  research_analyst:\n    backstory: Experienced in gathering and analyzing data related to AI news trends.\n    goal: Analyze AI News trends\n    role: Research Analyst\n    tasks:\n      gather_data:\n        description: Conduct in-depth research on the latest AI News trends from reputable\n          sources.\n        expected_output: Comprehensive report on current AI News trends.\n    tools:\n    - InternetSearchTool\n</code></pre>"},{"location":"deploy/","title":"Deploy","text":""},{"location":"deploy/#google-cloud","title":"Google Cloud","text":"<pre><code>gcloud init\ngcloud services enable run.googleapis.com\ngcloud services enable containerregistry.googleapis.com\ngcloud services enable cloudbuild.googleapis.com\n\nexport OPENAI_MODEL_NAME=\"gpt-4o\"\nexport OPENAI_API_KEY=\"Enter your API key\"\nexport OPENAI_API_BASE=\"https://api.openai.com/v1\"\n\nyes | gcloud auth configure-docker us-central1-docker.pkg.dev \ngcloud artifacts repositories create praisonai-repository --repository-format=docker --location=us-central1\n\nPROJECT_ID=$(gcloud config get-value project)\nTAG=\"latest\"\ndocker build --platform linux/amd64 -t gcr.io/${PROJECT_ID}/praisonai-app:${TAG} .\ndocker tag gcr.io/${PROJECT_ID}/praisonai-app:${TAG} us-central1-docker.pkg.dev/${PROJECT_ID}/praisonai-repository/praisonai-app:${TAG}\ndocker push us-central1-docker.pkg.dev/${PROJECT_ID}/praisonai-repository/praisonai-app:${TAG}\n\ngcloud run deploy praisonai-service \\\n    --image us-central1-docker.pkg.dev/${PROJECT_ID}/praisonai-repository/praisonai-app:${TAG} \\\n    --platform managed \\\n    --region us-central1 \\\n    --allow-unauthenticated \\\n    --set-env-vars OPENAI_MODEL_NAME=${OPENAI_MODEL_NAME},OPENAI_API_KEY=${OPENAI_API_KEY},OPENAI_API_BASE=${OPENAI_API_BASE}\n</code></pre>"},{"location":"initialise/","title":"Initialise","text":"<pre><code>export OPENAI_API_KEY=\"Enter your API key\"\n</code></pre> <p>Generate your OPENAI API KEY from here: https://platform.openai.com/api-keys</p> <p>Note: You can use other providers such as Ollama, Mistral ... etc. Details are provided at the bottom.</p> <p><pre><code>praisonai --init create a movie script about dog in moon\n</code></pre> This will automatically create agents.yaml file in the current directory.</p>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install praisonai\n</code></pre>"},{"location":"other_models/","title":"Other Models","text":"<pre><code>Ollama\nOPENAI_API_BASE='http://localhost:11434/v1'\nOPENAI_MODEL_NAME='mistral'\nOPENAI_API_KEY='NA'\n\nFastChat\u00b6\nOPENAI_API_BASE=\"http://localhost:8001/v1\"\nOPENAI_MODEL_NAME='oh-2.5m7b-q51'\nOPENAI_API_KEY=NA\n\nLM Studio\u00b6\nOPENAI_API_BASE=\"http://localhost:8000/v1\"\nOPENAI_MODEL_NAME=NA\nOPENAI_API_KEY=NA\n\nMistral API\u00b6\nOPENAI_API_BASE=https://api.mistral.ai/v1\nOPENAI_MODEL_NAME=\"mistral-small\"\nOPENAI_API_KEY=your-mistral-api-key\n</code></pre>"},{"location":"run/","title":"Run","text":"<pre><code>praisonai\n</code></pre> <p>or </p> <pre><code>python -m praisonai\n</code></pre>"},{"location":"run/#specify-the-agent-framework-optional","title":"Specify the agent framework (Optional):","text":"<pre><code>praisonai --framework autogen\n</code></pre>"},{"location":"run/#full-automatic-mode","title":"Full Automatic Mode","text":"<pre><code>praisonai --auto create a movie script about Dog in Moon\n</code></pre>"},{"location":"test/","title":"Test","text":"<pre><code>python -m unittest tests.test \n</code></pre>"},{"location":"tldr/","title":"TL;DR","text":"<pre><code>pip install praisonai\nexport OPENAI_API_KEY=\"Enter your API key\"\npraisonai --init create a movie script about dog in moon\npraisonai\n</code></pre>"},{"location":"ui/","title":"PraisonAI User Interface (UI)","text":""},{"location":"ui/#chainlit","title":"Chainlit","text":"<pre><code>pip install \"praisonai[ui]\"\nexport OPENAI_API_KEY=\"Enter your API key\"\npraisonai --ui chainlit\n</code></pre>"},{"location":"ui/#gradio","title":"Gradio","text":"<pre><code>pip install \"praisonai[gradio]\"\nexport OPENAI_API_KEY=\"Enter your API key\"\npraisonai --ui gradio\n</code></pre>"},{"location":"wrapper/","title":"Wrapper","text":""},{"location":"wrapper/#include-praisonai-package-in-your-project","title":"Include praisonai package in your project","text":"<p>Note: Please create agents.yaml file before hand. </p> <pre><code>from praisonai import PraisonAI\n\ndef basic(): # Basic Mode\n    praison_ai = PraisonAI(agent_file=\"agents.yaml\")\n    praison_ai.main()\n\nif __name__ == \"__main__\":\n    basic()\n</code></pre>"},{"location":"wrapper/#all-in-one","title":"All in one","text":"<pre><code>from praisonai import PraisonAI\n\ndef basic(): # Basic Mode\n    praison_ai = PraisonAI(agent_file=\"agents.yaml\")\n    praison_ai.main()\n\ndef advanced(): # Advanced Mode with options\n    praison_ai = PraisonAI(\n        agent_file=\"agents.yaml\",\n        framework=\"autogen\",\n    )\n    praison_ai.main()\n\ndef auto(): # Full Automatic Mode\n    praison_ai = PraisonAI(\n        auto=\"Create a movie script about car in mars\",\n        framework=\"autogen\"\n    )\n    print(praison_ai.framework)\n    praison_ai.main()\n\nif __name__ == \"__main__\":\n    basic()\n    advanced()\n    auto()\n</code></pre>"}]}